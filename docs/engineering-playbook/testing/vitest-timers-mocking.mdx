---
title: Vitest Timers Mocking
---

# Vitest Timers Mocking

A guide to using fake timers correctly in Vitest tests to avoid performance issues and flaky tests.

## Why Use Fake Timers?

Fake timers allow you to control time in your tests, making them:

- **Faster**: Skip waiting for real time delays
- **Deterministic**: Tests run consistently regardless of system load
- **Reliable**: No race conditions from timing variations

## The Problem: Setting Fake Timers Too Late

### ❌ Incorrect Pattern

**Problem**: Enabling fake timers after async operations and `waitFor` calls have already started.

```typescript
it('should reset state after timeout', async () => {
  expect.hasAssertions();

  // Component renders with real timers
  render(<NotificationComponent />);

  // User interaction with real timers
  await userEvent.click(screen.getByRole('button'));

  // waitFor uses real timers for polling
  await waitFor(() => {
    expect(screen.getByText('Success')).toBeInTheDocument();
  });

  // ❌ TOO LATE: Fake timers enabled after async operations
  vi.useFakeTimers({ shouldAdvanceTime: true });

  act(() => {
    vi.advanceTimersByTime(5000);
  });

  // ❌ PROBLEM: waitFor still uses real timers internally
  // This causes ~1000ms+ delay even though state may already be correct
  await waitFor(() => {
    expect(screen.queryByText('Success')).not.toBeInTheDocument();
  });

  vi.useRealTimers();
});
```

**Why This Fails**:

1. `waitFor` from React Testing Library uses real timers internally for polling
2. Even after advancing fake timers, `waitFor` continues polling with real time
3. This causes unnecessary delays (often 1000ms+) and makes tests slow
4. The test may pass, but it's inefficient and can be flaky

**Performance Impact**: Tests can take 10-15x longer than necessary (e.g., 87ms → 1300ms).

### ✅ Correct Pattern

**Solution**: Enable fake timers **before** any component rendering or async operations.

```typescript
it('should reset state after timeout', async () => {
  expect.hasAssertions();

  // ✅ Enable fake timers FIRST, before any rendering
  vi.useFakeTimers({ shouldAdvanceTime: true });

  render(<NotificationComponent />);

  // Now all timers (including userEvent and waitFor) use fake timers
  await userEvent.click(screen.getByRole('button'));

  await waitFor(() => {
    expect(screen.getByText('Success')).toBeInTheDocument();
  });

  // Advance fake timers - this works correctly now
  act(() => {
    vi.advanceTimersByTime(5000);
  });

  // waitFor now uses fake timers, so it's fast
  await waitFor(() => {
    expect(screen.queryByText('Success')).not.toBeInTheDocument();
  });

  // Clean up: restore real timers
  vi.useRealTimers();
});
```

**Why This Works**:

1. All timers (including those in `userEvent`, `waitFor`, and component code) use fake timers
2. `waitFor` polls using fake timers, so it's fast
3. Test runs deterministically and quickly
4. No race conditions from real-time delays

## Best Practices

### 1. Enable Fake Timers Early

Always enable fake timers **before**:

- Component rendering
- User interactions (`userEvent`)
- Any `waitFor` calls
- Any async operations that might use timers

```typescript
it('should handle delayed state update', async () => {
  expect.hasAssertions();

  // ✅ Enable at the start
  vi.useFakeTimers();

  // Then proceed with test setup
  const scope = fork({ values: [[$myStore, initialValue]] });
  render(<MyComponent />, {}, { effector: { scope } });

  // ... rest of test

  vi.useRealTimers();
});
```

### 2. Use `shouldAdvanceTime: true` When Needed

Use `shouldAdvanceTime: true` when you need to advance timers that are already scheduled:

```typescript
// For setTimeout/setInterval that are already running
vi.useFakeTimers({ shouldAdvanceTime: true });

// Advance time
act(() => {
  vi.advanceTimersByTime(5000);
});
```

### 3. Always Clean Up

Always restore real timers at the end of your test to avoid affecting other tests:

```typescript
it('should test timeout behavior', async () => {
  vi.useFakeTimers();

  // ... test code ...

  // ✅ Always restore
  vi.useRealTimers();
});
```

### 4. Alternative: Skip `waitFor` After Advancing Timers

If you've already advanced timers and the state update is synchronous, you can skip `waitFor`:

```typescript
it('should reset after timeout', async () => {
  expect.hasAssertions();

  vi.useFakeTimers({ shouldAdvanceTime: true });

  render(<Component />);
  await userEvent.click(screen.getByRole('button'));

  await waitFor(() => {
    expect(screen.getByText('Loading')).toBeInTheDocument();
  });

  // Advance timers
  act(() => {
    vi.advanceTimersByTime(5000);
  });

  // ✅ State should be updated synchronously after advancing timers
  // No need for waitFor if the update is immediate
  expect(screen.queryByText('Loading')).not.toBeInTheDocument();
  expect(screen.getByText('Complete')).toBeInTheDocument();

  vi.useRealTimers();
});
```

**Note**: This only works if the state update is synchronous. If there are async operations triggered by the timeout, you still need `waitFor`.

## Common Scenarios

### Scenario 1: Testing Component with `setTimeout`

```typescript
// Component code
useEffect(() => {
  if (isSuccess) {
    const timeoutId = setTimeout(() => {
      resetState();
    }, 5000);
    return () => clearTimeout(timeoutId);
  }
}, [isSuccess, resetState]);

// ✅ Correct test
it('should reset state after 5 seconds', async () => {
  expect.hasAssertions();

  vi.useFakeTimers({ shouldAdvanceTime: true });

  render(<Component />);
  await userEvent.click(screen.getByRole('button'));

  await waitFor(() => {
    expect(screen.getByText('Success')).toBeInTheDocument();
  });

  act(() => {
    vi.advanceTimersByTime(5000);
  });

  await waitFor(() => {
    expect(screen.queryByText('Success')).not.toBeInTheDocument();
  });

  vi.useRealTimers();
});
```

### Scenario 2: Testing Debounced Input

```typescript
// ✅ Correct test
it('should debounce search input', async () => {
  expect.hasAssertions();

  vi.useFakeTimers();

  render(<SearchInput />);
  const input = screen.getByRole('textbox');

  await userEvent.type(input, 'test query');

  // Search should not trigger immediately
  expect(screen.queryByText('Searching...')).not.toBeInTheDocument();

  // Advance past debounce delay (e.g., 300ms)
  act(() => {
    vi.advanceTimersByTime(300);
  });

  await waitFor(() => {
    expect(screen.getByText('Searching...')).toBeInTheDocument();
  });

  vi.useRealTimers();
});
```

### Scenario 3: Testing Polling Behavior

```typescript
// ✅ Correct test
it('should poll for updates every 10 seconds', async () => {
  expect.hasAssertions();

  vi.useFakeTimers({ shouldAdvanceTime: true });

  render(<PollingComponent />);

  // Initial render
  expect(screen.getByText('Data: initial')).toBeInTheDocument();

  // Advance 10 seconds - should trigger poll
  act(() => {
    vi.advanceTimersByTime(10000);
  });

  await waitFor(() => {
    expect(screen.getByText('Data: updated')).toBeInTheDocument();
  });

  vi.useRealTimers();
});
```

## Troubleshooting

### Test is Still Slow

- **Check**: Are fake timers enabled before rendering?
- **Check**: Are you using `waitFor` after advancing timers? Consider if it's necessary.
- **Check**: Are there any real timers still running? Look for `setTimeout`/`setInterval` outside of fake timer control.

### Test is Flaky

- **Check**: Are fake timers properly cleaned up with `vi.useRealTimers()`?
- **Check**: Are you advancing timers enough? Some operations may need more time.
- **Check**: Are there race conditions between fake timers and real async operations?

### `waitFor` Times Out

- **Check**: Is the state actually updating? The timeout might be correct.
- **Check**: Are fake timers enabled before `waitFor`? If not, `waitFor` uses real timers.
- **Check**: Do you need to advance timers more? Some operations may need additional time.

## Summary

1. **Enable fake timers early**: Before rendering, before user interactions, before `waitFor`
2. **Use `shouldAdvanceTime: true`**: When you need to advance already-scheduled timers
3. **Always clean up**: Call `vi.useRealTimers()` at the end of each test
4. **Consider skipping `waitFor`**: After advancing timers, if state updates are synchronous

Following these patterns ensures your tests are fast, deterministic, and reliable.
